#!/usr/bin/env bash

# ---------------------------------------------------------------
# sArch Installer (Server Arch)                                  |
# ---------------------------------------------------------------
# Author    : Binary-Brawler                                     |
# Github    : github.com/Binary-Brawler                          |
# LinkedIn  : linkedin.com/in/brandon-walker-0b0542116/          |
# Version   : 1.0.0                                              |
# Intent    : Server-ready Arch Linux for Dell EMC R540         |
#               - Intel C620 series chipset RAID support        |
#               - SSH enabled by default                         |
#               - Server-optimized packages                      |
#               - Monitoring and management tools                |
#               - Enterprise-grade security                      |
# ---------------------------------------------------------------
#                  Function - Purpose                            |
# ---------------------------------------------------------------------------
# slear               - Repeated Sleep/Clear function                        |
# greeter             - Entrypoint                                           |
# check_Net           - Checks internet speed for parallel downloads         |
# calculate_Swap_Size - if/else to determine SWAP size                       |
# partition_Drive     - Automated partitioning following basic Arch install  |
# installer           - Install base system and copy sArchPost script        |
# last_Min_Setup      - Installs second script in /mnt and                   |
# ---------------------------------------------------------------------------
# Constants
GREEN='\033[0;32m'
RED='\033[0;31m'
WHITE='\033[0;37m'
YELLOW='\033[0;33m'
PURPLE='\033[0;35m'
RESET='\033[0m'
NEWLINE=$'\n'
GITHUB='https://raw.githubusercontent.com/Binary-Brawler/hArch'

# Logging
log_warning() { echo -e "[${YELLOW}WARNING${RESET}] $1"; }
log_error() { echo -e "[${RED}ERROR${RESET}] $1"; }
print_info() { echo -e "[${GREEN}INFO${RESET}] $1${NEWLINE}"; }
log_success() { echo -e "[SUCCESS] $1"; }

function slear {
    sleep 3
    clear
}

function greeter {
    slear
	echo -e "${PURPLE}Server Arch Installer${RESET}"
	echo ${NEWLINE}
	echo ${NEWLINE}
    echo "-------------------------------------------------------------------------------------------------"
	echo -e ${YELLOW}
	echo ${NEWLINE}
	echo ${NEWLINE}
	echo " ███████ ▄▄▄       ██▀███   ▄████▄   ██░ ██     ██▓     ██▓ ███▄    █  █    ██ ▒██   ██▒"
	echo "▓██░ ██▒▒████▄    ▓██ ▒ ██▒▒██▀ ▀█  ▓██░ ██▒   ▓██▒    ▓██▒ ██ ▀█   █  ██  ▓██▒▒▒ █ █ ▒░"
	echo "▒██▀▀██░▒██  ▀█▄  ▓██ ░▄█ ▒▒▓█    ▄ ▒██▀▀██░   ▒██░    ▒██▒▓██  ▀█ ██▒▓██  ▒██░░░  █   ░"
	echo "░▓█ ░██ ░██▄▄▄▄██ ▒██▀▀█▄  ▒▓▓▄ ▄██▒░▓█ ░██    ▒██░    ░██░▓██▒  ▐▌██▒▓▓█  ░██░ ░ █ █ ▒ "
	echo "░▓█▒░██▓ ▓█   ▓██▒░██▓ ▒██▒▒ ▓███▀ ░░▓█▒░██▓   ░██████▒░██░▒██░   ▓██░▒▒█████▓ ▒██▒ ▒██▒"
	echo " ▒ ░░▒░▒ ▒▒   ▓▒█░░ ▒▓ ░▒▓░░ ░▒ ▒  ░ ▒ ░░▒░▒   ░ ▒░▓  ░░▓  ░ ▒░   ▒ ▒ ░▒▓▒ ▒ ▒ ▒▒ ░ ░▓ ░"
	echo " ▒ ░▒░ ░  ▒   ▒▒ ░  ░▒ ░ ▒░  ░  ▒    ▒ ░▒░ ░   ░ ░ ▒  ░ ▒ ░░ ░░   ░ ▒░░░▒░ ░ ░ ░░   ░▒ ░"
	echo " ░  ░░ ░  ░   ▒     ░░   ░ ░         ░  ░░ ░     ░ ░    ▒ ░   ░   ░ ░  ░░░ ░ ░  ░    ░  "
	echo " ░  ░  ░      ░  ░   ░     ░ ░       ░  ░  ░       ░  ░ ░           ░    ░      ░    ░  "
	echo "                           ░                                                            "
	echo -e "${RESET}"
	echo ${NEWLINE}
	echo ${NEWLINE}
    echo "-------------------------------------------------------------------------------------------------"
	echo -e "${GREEN}Server-Ready Arch Linux for Dell EMC R540${RESET}"
	echo -e "${YELLOW}Intel C620 Series Chipset RAID Support${RESET}"
	echo -e "${PURPLE}Enterprise-Grade Server Installation${RESET}"
	echo ${NEWLINE}
}

function check_Net {
    echo "---------------------------------------"
    print_info "Checking Internet Connection..."
    
    if ! command -v speedtest-cli &>/dev/null; then
        print_info "speedtest-cli is not installed. Installing..."
        pacman -Sy >/dev/null
        python3 -m venv speedTest && cd speedTest/bin/ && ./pip3 install speedtest-cli >/dev/null
    fi
    
    print_info "Calculating Internet Speed..."
    sleep 1
    local speed=$(./speedtest-cli --simple | awk '/^Download:/ {print $2}')
    sleep 1
    echo "------------------------------------"
    print_info "Download Speed: $speed Mbps"
    echo "------------------------------------"

    if (( $(echo "$speed > 50" | bc -l) )); then
        print_info "Enabling Parallel Downloads..."
        sed -i '/#ParallelDownloads/s/^#//g' /etc/pacman.conf
        echo "true" > enable_parallel.txt
    else
        print_info "Keeping Parallel Downloads Disabled as speed is too slow."
        echo "false" > enable_parallel.txt
    fi
}

# Calculate Swap Size Based on System RAM - Server optimized
function calculate_Swap_Size {
    local ram_gb=$(free -g | awk '/^Mem:/{print $2}')
    local swap_size="4G"

    if [[ ! $ram_gb =~ ^[0-9]+$ ]]; then
        log_error "Error: Could not determine RAM size." >&2
        exit 1
    fi

    # Server-optimized swap sizing
    if ((ram_gb < 4)); then
        swap_size="4G"
    elif ((ram_gb < 8)); then
        swap_size="8G"
    elif ((ram_gb < 16)); then
        swap_size="16G"
    elif ((ram_gb < 32)); then
        swap_size="32G"
    else
        swap_size="64G"
    fi

    echo "$swap_size"
}

function validate_partitions {
    local drive="$1"
    local is_uefi="$2"
    
    print_info "Validating partition scheme..."
    sleep 2
    
    # Check partition table type
    local partition_table=$(fdisk -l "$drive" 2>/dev/null | grep "Disklabel type:" | awk '{print $3}')
    
    if [[ "$is_uefi" == "true" ]]; then
        if [[ "$partition_table" != "gpt" ]]; then
            log_error "UEFI detected but GPT partition table not found!"
            log_error "Expected GPT, found: $partition_table"
            return 1
        fi
        print_info "✓ GPT partition table confirmed for UEFI"
        
        # Additional UEFI validation - check for EFI System Partition
        local efi_partition=""
        if [[ $drive == *nvme* ]]; then
            efi_partition="${drive}p1"
        elif [[ $drive == *sd* ]]; then
            efi_partition="${drive}1"
        fi
        
        if [[ -n "$efi_partition" ]]; then
            local efi_type=$(fdisk -l "$efi_partition" 2>/dev/null | grep "Type:" | awk '{print $2}')
            if [[ "$efi_type" == "EFI"* ]]; then
                print_info "✓ EFI System Partition confirmed"
            else
                log_warning "EFI partition type may not be correct: $efi_type"
            fi
        fi
        
    else
        if [[ "$partition_table" != "dos" ]]; then
            log_error "BIOS detected but MBR partition table not found!"
            log_error "Expected MBR (dos), found: $partition_table"
            return 1
        fi
        print_info "✓ MBR partition table confirmed for BIOS"
    fi
    
    return 0
}

function partition_Drive {
    local drive="$1"
    local swap_size=$(calculate_Swap_Size)
    local cmd_list=()
    
    # More robust UEFI detection
    local is_uefi=false
    if [[ -d "/sys/firmware/efi/efivars/" ]] && [[ -d "/sys/firmware/efi" ]] && [[ -f "/sys/firmware/efi/fw_platform_size" ]]; then
        # Additional check: verify EFI variables are actually accessible
        if ls /sys/firmware/efi/efivars/ >/dev/null 2>&1; then
            is_uefi=true
            print_info "Detected UEFI firmware"
        else
            print_info "EFI directory exists but variables not accessible - treating as BIOS"
        fi
    else
        print_info "Detected BIOS firmware"
    fi
    
    # Store firmware type for sArchPost script
    echo "$is_uefi" > firmware_type.txt

    if [[ "$is_uefi" == "true" ]]; then
        cmd_list=(
            "g"                          
            "n" "" "" "+512M"            
            "n" "" "" "+$swap_size"      
            "n" "" "" ""                 
            "t" "1" "1"                  
            "t" "2" "19"                 
            "w"                          
        )
    else
        cmd_list=(
            "o" "n" "p" "" "" "+$swap_size"   
            "n" "p" "" "" ""                  
            "t" "1" "82"                      
            "w"                               
        )
    fi

    printf "%s\n" "${cmd_list[@]}" | fdisk "$drive" >/dev/null 2>&1

    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to partition the drive."
        return 1
    fi
    
    # Validate partitions match firmware type
    if ! validate_partitions "$drive" "$is_uefi"; then
        log_error "Partition validation failed!"
        return 1
    fi

    if [[ "$is_uefi" == "true" ]]; then
        print_info "Setting up UEFI partitions..."
        
        if [[ $drive == *nvme* ]]; then
            print_info "Formatting EFI partition (${drive}p1) as FAT32..."
            mkfs.fat -F32 "${drive}p1" || { log_error "Failed to format EFI partition"; return 1; }
            
            print_info "Setting up SWAP partition (${drive}p2)..."
            mkswap "${drive}p2" || { log_error "Failed to setup SWAP partition"; return 1; }
            
            print_info "Formatting ROOT partition (${drive}p3) as ext4..."
            mkfs.ext4 "${drive}p3" || { log_error "Failed to format ROOT partition"; return 1; }

            print_info "Mounting ROOT partition..."
            mount "${drive}p3" /mnt || { log_error "Failed to mount ROOT partition"; return 1; }
            
            print_info "Creating EFI boot directory..."
            mkdir -p /mnt/boot/EFI || { log_error "Failed to create EFI directory"; return 1; }
            
            print_info "Mounting EFI partition..."
            mount "${drive}p1" /mnt/boot/EFI || { log_error "Failed to mount EFI partition"; return 1; }
            
            print_info "Enabling SWAP..."
            swapon "${drive}p2" || { log_error "Failed to enable SWAP"; return 1; }
            
        elif [[ $drive == *sd* ]]; then
            print_info "Formatting EFI partition (${drive}1) as FAT32..."
            mkfs.fat -F32 "${drive}1" || { log_error "Failed to format EFI partition"; return 1; }
            
            print_info "Setting up SWAP partition (${drive}2)..."
            mkswap "${drive}2" || { log_error "Failed to setup SWAP partition"; return 1; }
            
            print_info "Formatting ROOT partition (${drive}3) as ext4..."
            mkfs.ext4 "${drive}3" || { log_error "Failed to format ROOT partition"; return 1; }

            print_info "Mounting ROOT partition..."
            mount "${drive}3" /mnt || { log_error "Failed to mount ROOT partition"; return 1; }
            
            print_info "Creating EFI boot directory..."
            mkdir -p /mnt/boot/EFI || { log_error "Failed to create EFI directory"; return 1; }
            
            print_info "Mounting EFI partition..."
            mount "${drive}1" /mnt/boot/EFI || { log_error "Failed to mount EFI partition"; return 1; }
            
            print_info "Enabling SWAP..."
            swapon "${drive}2" || { log_error "Failed to enable SWAP"; return 1; }
            
        else
            log_error "Unsupported drive type for UEFI installation: $drive"
            return 1
        fi
        
        print_info "UEFI partition setup completed successfully"
        print_info "EFI partition mounted at: /mnt/boot/EFI"
        print_info "ROOT partition mounted at: /mnt"
        
        # Verify EFI partition setup
        if [[ -d "/mnt/boot/EFI" ]] && mountpoint -q "/mnt/boot/EFI"; then
            print_info "✓ EFI partition successfully mounted and accessible"
        else
            log_error "EFI partition mount verification failed!"
            return 1
        fi
    else
        if [[ $drive == *sd* ]]; then
            mkswap "${drive}1"         
            mkfs.ext4 "${drive}2"      

            swapon "${drive}1"
            mount "${drive}2" /mnt
        else
            echo "Error: Something happened with BIOS install..."
            return 1
        fi 
    fi
}

function installer {
    echo "--------------------------------"
    print_info "Installing Arch base with server packages..."
    sleep 2
    # Server-focused base installation with additional server packages
    pacstrap /mnt base base-devel linux linux-firmware linux-headers dkms \
        openssh iptables-nft ufw fail2ban htop iotop nethogs \
        lsof net-tools bind-tools curl wget git vim nano \
        systemd-resolvconf chrony \
        mdadm lvm2 smartmontools hdparm \
        intel-ucode >/dev/null 2>&1
    sleep 2
    genfstab -U /mnt >> /mnt/etc/fstab
}

function last_Min_Setup {
    echo "--------------------------------------"
    print_info "Finishing last minute setup..."
    echo 0 > /proc/sys/kernel/hung_task_timeout_secs
    mv enable_parallel.txt /mnt
    mv firmware_type.txt /mnt
    curl -O $GITHUB/main/sArchPost >/dev/null 2>&1
    chmod +x sArchPost
    mv sArchPost /mnt
    
    # Create server configuration directory
    mkdir -p /mnt/etc/server-config
    print_info "Downloading server configuration files..."
    
    # Create basic server configs
    cat > /mnt/etc/server-config/ssh_config << 'EOF'
# Server SSH Configuration
Port 22
Protocol 2
PermitRootLogin no
PasswordAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
X11Forwarding no
PrintMotd no
AcceptEnv LANG LC_*
Subsystem sftp /usr/lib/ssh/sftp-server
EOF

    cat > /mnt/etc/server-config/firewall_rules << 'EOF'
# Basic firewall rules for server
# Allow SSH
ufw allow 22/tcp
# Allow HTTP/HTTPS if needed
# ufw allow 80/tcp
# ufw allow 443/tcp
# Default deny
ufw default deny incoming
ufw default allow outgoing
EOF

    cat > /mnt/etc/server-config/raid_setup << 'EOF'
# Intel C620 Series RAID Configuration
# Load required modules
modprobe md_mod
modprobe raid1
modprobe raid0
modprobe raid10
modprobe raid456
modprobe linear

# Intel RST/RSTe support
modprobe ahci
modprobe intel_ahci
EOF
    
    echo  "----------------------------"
    print_info "Time to enter CHROOT"
    print_info "The final script has been installed and moved to your new root directory"
    print_info "Server configuration files are available in /etc/server-config/"
    print_info "Run these commands to finish setup"
    echo "------------------------------------------"
    echo ${NEWLINE}
    echo ${NEWLINE}
    echo -e "[1]${GREEN} arch-chroot /mnt${RESET}"
    echo -e "[2]${GREEN} ./sArchPost${RESET}"
    echo ${NEWLINE}
}

main() {
    greeter
    slear
    check_Net || { log_error "Check your Internet"; exit 1; }
    slear
    echo "----------------------------"
    print_info "Gathering drives..."
    echo ${NEWLINE}
    lsblk #TODO: Add something more robust
    echo ${NEWLINE}
    print_info "Time to select the drive you want too partition..."
    print_info "If you want to manually partition you may, just type exit after mounting /mnt"
    print_info "Otherwise, automated partition will create the standard BIOS/UEFI partitions"
    echo ${NEWLINE}
    echo "--------------------------------------"
    read -p "Manually partition [y/N]: " manual

    if [[ $manual == 'y' || $manual == 'Y' ]]; then
        echo "--------------------------------------"
        cfdisk "$drive"
        print_info "Entering BASH shell. Create filesystem and mount /mnt. Type exit once finished."
        echo "-----------------------------------------------------------------------------------------"
        bash
    else
        echo "----------------------------------------------"
        read -p "Enter Drive to prepare (e.g., /dev/sda): " drive
        echo "----------------------------"
        print_info "Modifying $drive..."
        sleep 3

        partition_Drive "$drive"
    fi

    installer || { log_error "Base system installation failed. Exiting."; exit 1; }

    slear
    
    last_Min_Setup || { log_warning "Last minute setup encountered issues."; exit 1; }

    log_success "sArch Installation completed successfully!"

}

main
